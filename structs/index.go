package structs

import (
	"database/sql"
	"log"
	"strings"
	//"unicode"

	"codeberg.org/neurocollective/wuxia/lib"
)

// id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
// user_id int NOT NULL,
// category_id int,
// value decimal NOT NULL,
// description text NOT NULL,
// date_occurred timestamp NOT NULL,
// create_date timestamp default now(),
// modified_date timestamp default now()

type Expenditure struct {
	Id           *lib.NotNull[int]     `json:"id"`
	UserId       *lib.NotNull[int]     `json:"userId"`
	CategoryId   *sql.Null[int]        `json:"categoryId"`
	Value        *lib.NotNull[float32] `json:"value"`
	Description  *lib.NotNull[string]  `json:"description"`
	DateOccurred *lib.NotNull[string]  `json:"dateOccurred"`
	CreateDate   *sql.Null[string]     `json:"createDate"`
	ModifiedDate *sql.Null[string]     `json:"modifiedDate"`
}

func (e Expenditure) ColumnNames() []string {
	columns := []string{
		"exp.id",
		"exp.user_id",
		"exp.category_id",
		"exp.value",
		"exp.description",
		"exp.date_occurred",
		"exp.create_date",
		"exp.modified_date",
	}
	return columns
}

func (e Expenditure) ColumnsString() string {
	return strings.Join(e.ColumnNames(), ",")
}

func ZeroedExpenditure() Expenditure {
	e := Expenditure{}

	e.Id = &lib.NotNull[int]{0}
	e.UserId = &lib.NotNull[int]{0}
	e.CategoryId = &sql.Null[int]{0, false}
	var floatZero float32 = 0.0
	e.Value = &lib.NotNull[float32]{floatZero}
	e.Description = &lib.NotNull[string]{""}
	e.DateOccurred = &lib.NotNull[string]{""}
	e.CreateDate = &sql.Null[string]{"", false}
	e.ModifiedDate = &sql.Null[string]{"", false}

	return e
}

func (e Expenditure) Columns() []any {
	return []any{
		e.Id,
		e.UserId,
		e.CategoryId,
		e.Value,
		e.Description,
		e.DateOccurred,
		e.CreateDate,
		e.ModifiedDate,
	}
}

func (e Expenditure) ColumnValues() []any {
	return []any{
		*e.Id,
		*e.UserId,
		*e.CategoryId,
		*e.Value,
		*e.Description,
		*e.DateOccurred,
		*e.CreateDate,
		*e.ModifiedDate,
	}
}

func (e Expenditure) Print() {
	columnNames := e.ColumnNames()
	for index, value := range e.ColumnValues() {

		log.Println(columnNames[index]+": ", value)
	}
}

func (e Expenditure) TableName() string {
	return "expenditure exp"
}

func InsertExpenditure(client *sql.DB, e Expenditure) error {
	queryString := "insert into expenditure values (nextval('expenditure_id_seq'), $1, $2, $3, $4, now(), now(), now());"

	// args := e.Columns()

	args := []any{
		e.UserId.V,
		nil,
		e.Value.V,
		e.Description.V,
	}

	_, err := client.Query(queryString, args...)

	if err != nil {
		return err
	}
	return nil
}

func ReceiveExpenditures(rows *sql.Rows) ([]Expenditure, error) {
	var empty []Expenditure

	capacity := 100

	rowArray := make([]Expenditure, capacity, capacity)
	var index int

	// resultsExist := rows.NextResultSet()

	// if !resultsExist {
	// 	err := rows.Err()

	// 	if err != nil {
	// 		log.Println("error getting rows:", err)
	// 		return empty, err
	// 	}
	// 	log.Println("no results!")
	// 	return empty, nil
	// }

	for rows.Next() {

		receiver := ZeroedExpenditure()

		if index == capacity-1 {
			capacity += 100
			newRowArray := make([]Expenditure, 0, capacity)

			copy(newRowArray, rowArray)
			rowArray = newRowArray
		}

		values := receiver.Columns()

		log.Println("columns:", values)

		err := rows.Scan(values...)

		if err != nil {
			log.Println("scanError", err.Error())
			return empty, err
		}

		rowArray[index] = receiver
		index++
	}

	return rowArray[:index], nil
}

const TEXT = "text"
const VARCHAR = "varchar"
const INTEGER = "integer"
const NUMERIC = "numeric"
const TIMESTAMP = "timestamp"
const NOT = "not"
const NULL = "null"
const SPACE = " "

type ColumnDefinition struct {
	Name     string
	Type     string
	Nullable bool
	Tag      string
}

type TableSchema struct {
	Name    string
	Columns []ColumnDefinition
}

type Schema struct {
	Tables []TableSchema
}

func TranslateTypeToGo(sqlType string) string {
	if sqlType == TEXT || sqlType == VARCHAR {
		return "string"
	}
	if sqlType == NUMERIC {
		return "float32"
	}
	if sqlType == INTEGER {
		return "int"
	}
	if sqlType == TIMESTAMP {
		return "string"
	}
	return ""
}

func GetNullableWuxiaType(goType string) string {
	return "*sql.Null[" + goType + "]"
}

func GetNotNullWuxiaType(goType string) string {
	return "*lib.NotNull[" + goType + "]"
}

func TranslateGoTypeToWuxia(goType string, nullable bool) string {
	if nullable {
		return GetNullableWuxiaType(goType)
	}
	return GetNotNullWuxiaType(goType)
}

func UpperCaseColumnName(name string) string {

	characters := make([]string, 0, len(name))

	for index, rune := range name {
		if index > 0 {
			characters = append(characters, string(rune))
		} else {
			asString := string(rune)
			characters = append(characters, strings.ToUpper(asString))
		}
	}
	return strings.Join(characters, "")
}

func (ts TableSchema) GetStructString() string {

	lines := make([]string, 0, len(ts.Columns)+2)

	lines = append(lines, "type "+ts.Name+" struct {")

	for _, column := range ts.Columns {
		goType := TranslateTypeToGo(column.Type)
		elements := []string{
			SPACE,
			SPACE,
			UpperCaseColumnName(column.Name),
			SPACE,
			TranslateGoTypeToWuxia(goType, column.Nullable),
			SPACE,
			column.Tag,
		}
		nextLine := strings.Join(elements, "")

		lines = append(lines, nextLine)
	}

	lines = append(lines, "}")

	return strings.Join(lines, "\n")
}
