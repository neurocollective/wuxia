package structs

import (
	"database/sql"
	"strings"
	"log"
	"codeberg.org/neurocollective/wuxia/lib"
)

// id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
// user_id int NOT NULL,
// category_id int,
// value decimal NOT NULL,
// description text NOT NULL,
// date_occurred timestamp NOT NULL,
// create_date timestamp default now(),
// modified_date timestamp default now()

type Expenditure struct {
	Id           *lib.NotNull[int]     `json:"id"`
	UserId       *lib.NotNull[int]     `json:"userId"`
	CategoryId   *sql.Null[int]    `json:"categoryId"`
	Value        *lib.NotNull[float32] `json:"value"`
	Description  *lib.NotNull[string]  `json:"description"`
	DateOccurred *lib.NotNull[string]  `json:"dateOccurred"`
	CreateDate   *sql.Null[string] `json:"createDate"`
	ModifiedDate *sql.Null[string] `json:"modifiedDate"`
}

func (e Expenditure) ColumnNames() []string {
	columns := []string{
		"exp.id",
		"exp.user_id",
		"exp.category_id",
		"exp.value",
		"exp.description",
		"exp.date_occurred",
		"exp.create_date",
		"exp.modified_date",
	}
	return columns
}

func (e Expenditure) ColumnsString() string {
	return strings.Join(e.ColumnNames(), ",")
}

func ZeroedExpenditure() Expenditure {
	e := Expenditure{}

	e.Id = &lib.NotNull[int]{0}
	e.UserId = &lib.NotNull[int]{0}
	e.CategoryId = &sql.Null[int]{0, false}
	var floatZero float32 = 0.0
	e.Value = &lib.NotNull[float32]{floatZero}
	e.Description = &lib.NotNull[string]{""}
	e.DateOccurred = &lib.NotNull[string]{""}
	e.CreateDate = &sql.Null[string]{"", false}
	e.ModifiedDate = &sql.Null[string]{"", false}

	return e
}

func (e Expenditure) Columns() []any {
	return []any{
		e.Id,
		e.UserId,
		e.CategoryId,
		e.Value,
		e.Description,
		e.DateOccurred,
		e.CreateDate,
		e.ModifiedDate,
	}
}

func (e Expenditure) ColumnValues() []any {
	return []any{
		*e.Id,
		*e.UserId,
		*e.CategoryId,
		*e.Value,
		*e.Description,
		*e.DateOccurred,
		*e.CreateDate,
		*e.ModifiedDate,
	}
}

func (e Expenditure) Print() {
	columnNames := e.ColumnNames()
	for index, value := range e.ColumnValues() {

		log.Println(columnNames[index]+": ", value)
	}
}

func (e Expenditure) TableName() string {
	return "expenditure exp"
}

func InsertExpenditure(client *sql.DB, e Expenditure) error {
	queryString := "insert into expenditure values (nextval('expenditure_id_seq'), $1, $2, $3, $4, now(), now(), now());"

	// args := e.Columns()

	args := []any{
		e.UserId.V,
		nil,
		e.Value.V,
		e.Description.V,
	}

	_, err := client.Query(queryString, args...)

	if err != nil {
		return err
	}
	return nil
}

func ReceiveExpenditures(rows *sql.Rows) ([]Expenditure, error) {
	var empty []Expenditure

	capacity := 100

	rowArray := make([]Expenditure, capacity, capacity)
	var index int

	// resultsExist := rows.NextResultSet()

	// if !resultsExist {
	// 	err := rows.Err()

	// 	if err != nil {
	// 		log.Println("error getting rows:", err)
	// 		return empty, err
	// 	}
	// 	log.Println("no results!")
	// 	return empty, nil
	// }

	for rows.Next() {

		receiver := ZeroedExpenditure()

		if index == capacity-1 {
			capacity += 100
			newRowArray := make([]Expenditure, 0, capacity)

			copy(newRowArray, rowArray)
			rowArray = newRowArray
		}

		values := receiver.Columns()

		log.Println("columns:", values)

		err := rows.Scan(values...)

		if err != nil {
			log.Println("scanError", err.Error())
			return empty, err
		}

		rowArray[index] = receiver
		index++
	}

	return rowArray[:index], nil
}